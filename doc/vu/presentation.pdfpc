[file]
presentation.pdf
[notes]
### 1
Vorstellen,
HW/SW Entwurfssprachen -> System Level Design (Languages)
Ich über SDL,
Thomas Schwerpunkt SystemC
### 2
S2
### 3
emebedded systems -> resourceneffizient (was hw/sw??)
viele sub-systems (hw/sw/algos) -> steigende complex
-> next bild erklären
- Design wiederverwendung
- Teamarbeit
- Projekt wiederverwendbarkeit
- Automation 
- Abstraktion (-> hier potential, auf RTL ebene stecken geblieben)
=> Suchen wir ein neues Abstraktionslevel von HW/SW. (in der mitte treffen)
### 4
Neue Abstraktionsebene heißt SDL (sehr abstrakt)
TLM = nur die details die im momentaningen design prozess gebraucht werden sind von interesse (rest abstrakt)
[JPEG example]
TLM unabhängig der Sprache (feature support aber nie schlecht -> automation, z.B.: cross compiler auf spezielle zielarch)
2010 DVCon OSCI (Open SystemC Initiative) - vorgestellt synthetisierbares TLM subset
SystemC - accelera systems initiative
SpecC - AnsiC by Embedded Computing Systems at University of California (hptsächl. Japan)
System Verilog - Verilog + Verficiation 
### 5
SysC versucht Vorteile von HDLs und Hochsprachen zu vereinen. 
TLM wie vorhin erwähnt - Designcycle verkürzen (Virtual Prototyping), Partitioning vereinfachen - probieren wird Zeiteffizient (erspart einige HW Designcyclen)
### 6
AMS = Analog Mixed Signals (analog mixed signals at higher abstraction levels)
SCV = System C Verification
CCI = Configuration, Control and Inspection (Standard für den Austausch zwischen models und tools) - also z.B.: IP Cores und Messwerkzeuge (Inspection)
### 7
ARM LTd, CoWare, Synopsys and CynApps -> SystemC initiative
1999: Basis Funktionen (4-wertige logic, 0,1,X,Z), ClockCycle Accuracy, Delta Cycles, Module
2001: 2.0 erweitert um primitive trigger, interfaces and ports
LRM - Language Reference Manual
OSCI veröffentlichte einen proof of conecept simulator
IEEE standardisierung
### 8
Hochsprachen gibt es viele, während VHDL und Verilog die vorherrschende HDLs sind. 
Vera E: Verifikation
Matlab: Algos -> system requirements
### 9
Drawback:
Viele Dinge müssen aber noch händisch gemacht werden und sind noch nicht automatisiert - Industrie braucht noch weiter Zeit um sich an die neuen Optionen zu "gewöhnen"
### 10
Konkret: C-Software und Verifikation, SystemC-HW/SW-Verifikation, VHDL - HW

C: z.b. kein Z wert für tri-state -  eher die sprache um funtkionierende hardware anzusprechen (mircocontroller,cpu - ungeeignet für hardwaremodellierung)

VHDL: Funktionale verification schwierig, sehr komplex um alles mit TB abzudecken, für softwareprojekte eher ungeeignet ( hw/sw codesign) 
SystemC: klassenerweiterung von C++, GitHub, komplexität besser managen.
Nachteile: syntaktischer overhead, debug C++,nicht SysC

Vorteile: man hat nur eine sprache ,verfeinerungen werden natürlich in VHDL und C gemacht, leicht zu lernen, Open Source, Funktionale Verification
In version 3 von systemC sollen ganze betriebssysteme modelliert werden können.
### 11
C rein auf software bezogene datentypen, hardwaredatentypen fehlen

VHDL hat auch integer aber long short union eher ned
kann natürlich definiert werden, höherer aufwand

SystemC mischt das ganze

präfix systemC (sc_*)
### 12
Vergleich von den programmiersprachen

C: entity wäre c header
SysC: SC_MODULE spiegelt am ehesten die entity wieder
VHDL: entity sample_entity is port( input: port1 std_logic;....

C: modularisierung; funktionen in *.c files anlegen
SysC: in SC_MODULE gliedern
VHDL: entities erstellen, packages...

### 13
Modulkopf kann als entity gesehen werden, deklarationen werden dort gemacht (input sowie output)

dann kommt der process der ausgeführt wird, je nachdem wie die sensitivity list unten konfiguriert ist.

SC_CTOR beinhaltet die prozesse (SC_METHOD()) und die sensitivity sachn.

DEMO
### 14
was ist partitioning?

modellierung von hw und sw, versch. ebenen: verhalten bis rtl ebene. macht es möglich hw und sw in einer höheren sprache zu spezifizieren.
### 15
Partitioning-technologien, Graphentheorie (Discrete Mathematics)

Kerninghan-Lin (lösung des Graphpartitionierungsproblems)

Simulated annealing - (Algorithmen und Datenstrukturen 2)

LegUP Uni Toronto, kann ganzes oder gewählte teile von C programm in hardware modelieren, verbleibende software - TigerMIPS (softcore)



### 16
gcc/g++ mit gdb und natürlich systemC 2.3.0/2.3.1 für die kompilierung.

Catapult SL/LP - nimmt C/C++ oder SystemC als input und generiert Register Transfer Level code für FPGAs oder ASICs. Komplette suite zum programmieren und verifizieren. 

### 17
Derzeit jobs in österreich betreffend SystemC (NXP Infineon)

Cadence success stories, stehen viele projekte von namhaften oder eher unbekannten firmen.

ARM hat Softcores welche in SystemC code verfügbar sind und auch simuliert werden können. ARM hat genau so wie AMD eine aktive community und die community seite wird von mitarbeitern supportet.

Auf Accerella gibt es auch ein paar (ältere) success stories.

Kompilieren von systemC kann man kostenlos (open source), tools für die verwendung (Catapult, Cadence, Synopsis ...) kostenpflichtig, sind ja für die verschiedenen FPGAs
